const Anthropic = require('@anthropic-ai/sdk');
const axios = require('axios');

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_USERNAME = process.env.GITHUB_USERNAME;
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;
const SECRET_CODE = process.env.SECRET_CODE;

const anthropic = new Anthropic({
  apiKey: ANTHROPIC_API_KEY,
  baseURL: 'https://aipipe.iitm.ac.in/anthropic/v1'
});

// ===== Helper functions =====
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

function decodeDataURI(dataUri) {
  const matches = dataUri.match(/^data:([^;]+);base64,(.+)$/);
  if (!matches) return null;
  const mimeType = matches[1];
  const base64Data = matches[2];
  const content = Buffer.from(base64Data, 'base64').toString('utf-8');
  return { mimeType, content };
}

async function generateCode(brief, checks, attachments) {
  let attachmentDetails = '';
  if (attachments && attachments.length > 0) {
    attachmentDetails = '\n\nATTACHMENTS (decode and use these):\n';
    for (const att of attachments) {
      if (att.url.startsWith('data:')) {
        const decoded = decodeDataURI(att.url);
        if (decoded) attachmentDetails += `\nFile: ${att.name}\nContent:\n${decoded.content}\n`;
      } else {
        attachmentDetails += `\nFile: ${att.name}\nURL: ${att.url}\n`;
      }
    }
  }

  const prompt = `You are an expert web developer. Create a COMPLETE, WORKING single HTML file.

BRIEF: ${brief}

VALIDATION CHECKS (your code MUST pass these):
${checks.map((c, i) => `${i + 1}. ${c}`).join('\n')}
${attachmentDetails}

CRITICAL REQUIREMENTS:
- Create ONE complete HTML file with ALL code inline
- Include CSS in <style> tags in <head>
- Include JavaScript in <script> tags before </body>
- For CSV data: parse it correctly, handle the sales column
- For Bootstrap: load from jsdelivr CDN
- Make EVERY check pass exactly as specified
- Use proper selectors (e.g., #total-sales)
- Handle edge cases and data parsing carefully
- If attachments have CSV/JSON data, parse and use them correctly

Output ONLY the complete HTML code. No markdown, no explanations.`;

  const message = await anthropic.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 4096,
    messages: [{ role: 'user', content: prompt }]
  });

  let code = message.content[0].text;
  code = code.replace(/```html\n?/g, '').replace(/```\n?/g, '').trim();
  return code;
}

async function createGitHubRepo(repoName) {
  try {
    const res = await axios.post('https://api.github.com/user/repos', {
      name: repoName,
      description: 'Auto-generated by LLM deployment system',
      private: false,
      auto_init: false
    }, {
      headers: { Authorization: `token ${GITHUB_TOKEN}` }
    });
    return res.data;
  } catch (err) {
    if (err.response?.status === 422) {
      console.log(`Repo ${repoName} exists, using existing repo`);
      return { name: repoName };
    }
    throw err;
  }
}

async function pushFileToGitHub(repoName, filePath, content, message) {
  const url = `https://api.github.com/repos/${GITHUB_USERNAME}/${repoName}/contents/${filePath}`;
  await axios.put(url, {
    message,
    content: Buffer.from(content).toString('base64')
  }, { headers: { Authorization: `token ${GITHUB_TOKEN}` } });
}

async function enableGitHubPages(repoName) {
  try {
    await axios.post(`https://api.github.com/repos/${GITHUB_USERNAME}/${repoName}/pages`, {
      source: { branch: 'main', path: '/' }
    }, { headers: { Authorization: `token ${GITHUB_TOKEN}` } });
  } catch (err) {
    if (err.response?.status === 409) console.log('GitHub Pages already enabled');
    else throw err;
  }
}

async function getLatestCommitSHA(repoName) {
  const res = await axios.get(`https://api.github.com/repos/${GITHUB_USERNAME}/${repoName}/commits/main`, {
    headers: { Authorization: `token ${GITHUB_TOKEN}` }
  });
  return res.data.sha;
}

async function updateFileOnGitHub(repoName, filePath, content, message) {
  const url = `https://api.github.com/repos/${GITHUB_USERNAME}/${repoName}/contents/${filePath}`;
  const currentFile = await axios.get(url, {
    headers: { Authorization: `token ${GITHUB_TOKEN}` }
  });
  await axios.put(url, {
    message,
    content: Buffer.from(content).toString('base64'),
    sha: currentFile.data.sha
  }, { headers: { Authorization: `token ${GITHUB_TOKEN}` } });
}

async function notifyEvaluationURL(evaluationUrl, payload) {
  const maxRetries = 5;
  const retryDelays = [1000, 2000, 4000, 8000, 16000];
  for (let i = 0; i < maxRetries; i++) {
    try {
      const res = await axios.post(evaluationUrl, payload, { headers: { 'Content-Type': 'application/json' }, timeout: 30000 });
      if (res.status === 200) return { success: true };
    } catch (err) {
      console.error(`Attempt ${i + 1} failed:`, err.message);
      if (i < maxRetries - 1) await delay(retryDelays[i]);
      else throw err;
    }
  }
}

function generateREADME(brief, repoName) {
  return `# ${repoName}

## Summary
${brief}

## Live Demo
Visit: https://${GITHUB_USERNAME}.github.io/${repoName}/

## Auto-generated
This project was created by an LLM-powered deployment system.
`;
}

const MIT_LICENSE = `MIT License

Copyright (c) 2025

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction...
`;

// ===== API Handler =====
module.exports = async (req, res) => {
  if (req.method === 'GET') return res.status(200).json({ success: true, message: 'API running' });

  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });

  try {
    const { email, secret, task, round, nonce, brief, checks, evaluation_url, attachments = [] } = req.body;

    if (secret !== SECRET_CODE) return res.status(401).json({ error: 'Invalid secret' });
    if (!email || !task || !round || !nonce || !brief || !evaluation_url)
      return res.status(400).json({ error: 'Missing required fields' });

    // Immediate response to avoid timeout
    res.status(200).json({ success: true, message: 'Task received', task, round, nonce });

    // === Async processing in same file ===
    (async () => {
      try {
        const repoName = task.toLowerCase().replace(/[^a-z0-9-]/g, '-');
        console.log(`Processing task: ${task}, round: ${round}`);

        const htmlCode = await generateCode(brief, checks, attachments);

        if (round === 1) {
          await createGitHubRepo(repoName);
          await delay(2000);

          await pushFileToGitHub(repoName, 'LICENSE', MIT_LICENSE, 'Add MIT License');
          await delay(1000);

          const readme = generateREADME(brief, repoName);
          await pushFileToGitHub(repoName, 'README.md', readme, 'Add README');
          await delay(1000);

          await pushFileToGitHub(repoName, 'index.html', htmlCode, 'Add main application');
          await delay(2000);

          await enableGitHubPages(repoName);
          await delay(5000);

          const commitSha = await getLatestCommitSHA(repoName);
          await notifyEvaluationURL(evaluation_url, { email, task, round, nonce, repo_url: `https://github.com/${GITHUB_USERNAME}/${repoName}`, commit_sha: commitSha, pages_url: `https://${GITHUB_USERNAME}.github.io/${repoName}/` });
          console.log(`Round 1 completed for ${task}`);
        } else if (round === 2) {
          await updateFileOnGitHub(repoName, 'index.html', htmlCode, `Round 2: Update application`);
          await delay(1000);

          const readme = generateREADME(brief, repoName);
          await updateFileOnGitHub(repoName, 'README.md', readme, 'Update README for Round 2');
          await delay(5000);

          const commitSha = await getLatestCommitSHA(repoName);
          await notifyEvaluationURL(evaluation_url, { email, task, round, nonce, repo_url: `https://github.com/${GITHUB_USERNAME}/${repoName}`, commit_sha: commitSha, pages_url: `https://${GITHUB_USERNAME}.github.io/${repoName}/` });
          console.log(`Round 2 completed for ${task}`);
        }
      } catch (err) {
        console.error('Async processing error:', err.message || err);
      }
    })();

  } catch (err) {
    console.error('Request handling error:', err.message || err);
  }
};

