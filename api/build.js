const Anthropic = require('@anthropic-ai/sdk');
const axios = require('axios');

// Environment variables
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_USERNAME = process.env.GITHUB_USERNAME;
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;
const SECRET_CODE = process.env.SECRET_CODE;
const STUDENT_EMAIL = process.env.STUDENT_EMAIL;

// Initialize Anthropic client with aipipe
const anthropic = new Anthropic({
  apiKey: ANTHROPIC_API_KEY,
  baseURL: 'https://aipipe.iitm.ac.in/anthropic/v1'
});

// Helper: Delay function
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Helper: Generate code using Claude
async function generateCode(brief, checks, attachments) {
  const attachmentInfo = attachments.length > 0 
    ? `\n\nAttachments provided:\n${attachments.map(a => `- ${a.name}: ${a.url.substring(0, 100)}...`).join('\n')}`
    : '';

  const prompt = `You are an expert web developer. Create a single HTML file that satisfies this brief:

BRIEF: ${brief}

CHECKS (the app will be evaluated against these):
${checks.map((c, i) => `${i + 1}. ${c}`).join('\n')}
${attachmentInfo}

REQUIREMENTS:
- Create a COMPLETE, WORKING single HTML file
- Include ALL CSS inline in <style> tags
- Include ALL JavaScript inline in <script> tags
- Use modern, clean design
- Make it fully functional
- Handle edge cases
- If attachments are provided, fetch and use them appropriately
- For data URIs in attachments, decode and use them directly

Output ONLY the complete HTML code, no explanations.`;

  const message = await anthropic.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 4096,
    messages: [{
      role: 'user',
      content: prompt
    }]
  });

  return message.content[0].text;
}

// Helper: Create GitHub repo
async function createGitHubRepo(repoName) {
  const response = await axios.post(
    'https://api.github.com/user/repos',
    {
      name: repoName,
      description: 'Auto-generated by LLM deployment system',
      private: false,
      auto_init: false
    },
    {
      headers: {
        'Authorization': `token ${GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    }
  );
  return response.data;
}

// Helper: Push file to GitHub
async function pushFileToGitHub(repoName, filePath, content, message) {
  const url = `https://api.github.com/repos/${GITHUB_USERNAME}/${repoName}/contents/${filePath}`;
  
  await axios.put(
    url,
    {
      message: message,
      content: Buffer.from(content).toString('base64')
    },
    {
      headers: {
        'Authorization': `token ${GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    }
  );
}

// Helper: Enable GitHub Pages
async function enableGitHubPages(repoName) {
  await axios.post(
    `https://api.github.com/repos/${GITHUB_USERNAME}/${repoName}/pages`,
    {
      source: {
        branch: 'main',
        path: '/'
      }
    },
    {
      headers: {
        'Authorization': `token ${GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    }
  );
}

// Helper: Get latest commit SHA
async function getLatestCommitSHA(repoName) {
  const response = await axios.get(
    `https://api.github.com/repos/${GITHUB_USERNAME}/${repoName}/commits/main`,
    {
      headers: {
        'Authorization': `token ${GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    }
  );
  return response.data.sha;
}

// Helper: Update existing file
async function updateFileOnGitHub(repoName, filePath, content, message) {
  const url = `https://api.github.com/repos/${GITHUB_USERNAME}/${repoName}/contents/${filePath}`;
  
  // Get current file SHA
  const currentFile = await axios.get(url, {
    headers: {
      'Authorization': `token ${GITHUB_TOKEN}`,
      'Accept': 'application/vnd.github.v3+json'
    }
  });
  
  await axios.put(
    url,
    {
      message: message,
      content: Buffer.from(content).toString('base64'),
      sha: currentFile.data.sha
    },
    {
      headers: {
        'Authorization': `token ${GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    }
  );
}

// Helper: Notify evaluation URL with retry
async function notifyEvaluationURL(evaluationUrl, payload) {
  const retryDelays = [1000, 2000, 4000, 8000];
  
  for (let i = 0; i <= retryDelays.length; i++) {
    try {
      const response = await axios.post(evaluationUrl, payload, {
        headers: { 'Content-Type': 'application/json' },
        timeout: 30000
      });
      
      if (response.status === 200) {
        return { success: true, response: response.data };
      }
    } catch (error) {
      if (i < retryDelays.length) {
        await delay(retryDelays[i]);
      } else {
        throw error;
      }
    }
  }
}

// Helper: Generate README
function generateREADME(brief, repoName) {
  return `# ${repoName}

## Summary
This project was auto-generated to satisfy the following requirement:

${brief}

## Setup
No setup required. This is a static HTML page.

## Usage
1. Visit the deployed page at: https://${GITHUB_USERNAME}.github.io/${repoName}/
2. The page will automatically load and execute as specified in the brief

## Code Explanation
- **index.html**: Main application file containing all HTML, CSS, and JavaScript
- All functionality is self-contained within a single file for simplicity
- Uses modern vanilla JavaScript for interactions
- Responsive design using inline CSS

## License
MIT License - see LICENSE file for details

---
Auto-generated by LLM Deployment System
`;
}

// Helper: MIT License content
const MIT_LICENSE = `MIT License

Copyright (c) 2025 ${GITHUB_USERNAME}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.`;

// Main handler
module.exports = async (req, res) => {
  // Only accept POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { email, secret, task, round, nonce, brief, checks, evaluation_url, attachments = [] } = req.body;

    // Validate secret
    if (secret !== SECRET_CODE) {
      return res.status(401).json({ error: 'Invalid secret' });
    }

    // Validate required fields
    if (!email || !task || !round || !nonce || !brief || !evaluation_url) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Return 200 immediately
    res.status(200).json({ 
      success: true, 
      message: 'Request received. Processing...',
      task: task,
      round: round
    });

    // Continue processing asynchronously
    (async () => {
      try {
        const repoName = task.toLowerCase().replace(/[^a-z0-9-]/g, '-');
        
        if (round === 1) {
          // ROUND 1: Create new repo
          console.log(`Creating repo: ${repoName}`);
          
          // Generate code
          const htmlCode = await generateCode(brief, checks, attachments);
          
          // Create repository
          await createGitHubRepo(repoName);
          await delay(2000); // Wait for repo to be ready
          
          // Push LICENSE
          await pushFileToGitHub(repoName, 'LICENSE', MIT_LICENSE, 'Add MIT License');
          await delay(1000);
          
          // Push README
          const readme = generateREADME(brief, repoName);
          await pushFileToGitHub(repoName, 'README.md', readme, 'Add README');
          await delay(1000);
          
          // Push index.html
          await pushFileToGitHub(repoName, 'index.html', htmlCode, 'Add main application');
          await delay(2000);
          
          // Enable GitHub Pages
          await enableGitHubPages(repoName);
          await delay(5000); // Wait for Pages to be enabled
          
          // Get commit SHA
          const commitSha = await getLatestCommitSHA(repoName);
          
          // Prepare notification payload
          const payload = {
            email: email,
            task: task,
            round: round,
            nonce: nonce,
            repo_url: `https://github.com/${GITHUB_USERNAME}/${repoName}`,
            commit_sha: commitSha,
            pages_url: `https://${GITHUB_USERNAME}.github.io/${repoName}/`
          };
          
          // Notify evaluation URL
          await notifyEvaluationURL(evaluation_url, payload);
          
          console.log(`Round 1 complete for ${task}`);
          
        } else if (round === 2) {
          // ROUND 2: Update existing repo
          console.log(`Updating repo: ${repoName}`);
          
          // Generate updated code
          const htmlCode = await generateCode(brief, checks, attachments);
          
          // Update index.html
          await updateFileOnGitHub(repoName, 'index.html', htmlCode, `Round 2: ${brief.substring(0, 50)}`);
          await delay(1000);
          
          // Update README
          const readme = generateREADME(brief, repoName);
          await updateFileOnGitHub(repoName, 'README.md', readme, 'Update README for Round 2');
          await delay(5000); // Wait for Pages to rebuild
          
          // Get commit SHA
          const commitSha = await getLatestCommitSHA(repoName);
          
          // Prepare notification payload
          const payload = {
            email: email,
            task: task,
            round: round,
            nonce: nonce,
            repo_url: `https://github.com/${GITHUB_USERNAME}/${repoName}`,
            commit_sha: commitSha,
            pages_url: `https://${GITHUB_USERNAME}.github.io/${repoName}/`
          };
          
          // Notify evaluation URL
          await notifyEvaluationURL(evaluation_url, payload);
          
          console.log(`Round 2 complete for ${task}`);
        }
        
      } catch (asyncError) {
        console.error('Async processing error:', asyncError);
      }
    })();

  } catch (error) {
    console.error('Error:', error);
    // Already sent 200, so we can't send error response
  }
};
